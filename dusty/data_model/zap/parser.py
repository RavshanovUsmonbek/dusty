
import re
import socket
from urllib.parse import urlparse
from defusedxml import ElementTree as ET
from markdownify import markdownify as md
from dusty.data_model.canonical_model import Endpoint, DefaultModel as Finding


class ZapXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the zap tool.
    TODO: Handle errors.
    TODO: Test zap output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.
    @param zap_xml_filepath A proper xml generated by zap
    """

    def __init__(self, xml_output, test):
        tree = self.parse_xml(xml_output)

        if tree:
            self.items = self.get_items(tree, test)
        else:
            self.items = []

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.
        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.
        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.parse(xml_output)
        except SyntaxError as se:
            raise se

        return tree

    def get_items(self, tree, test):
        """
        @return items A list of Host instances
        """

        items = list()
        for node in tree.findall('site'):
            site = Site(node)
            main_host = Endpoint(host=site.ip + site.port if site.port is not None else "")
            for item in site.items:
                severity = item.riskdesc.split(' ', 1)[0]
                references = ''
                for ref in item.ref:
                    references += ref + "\n"

                find = Finding(title=item.name,
                               tool="ZAP",
                               cwe=item.cwe,
                               description=md(item.desc),
                               test=test,
                               severity=severity,
                               mitigation=md(item.resolution),
                               references=references,
                               active=False,
                               verified=False,
                               false_p=False,
                               duplicate=False,
                               out_of_scope=False,
                               mitigated=None,
                               impact="No impact provided",
                               numerical_severity=Finding.get_numerical_severity(severity))

                find.unsaved_endpoints = [main_host]
                for i in item.items:
                    parts = urlparse(i['uri'])
                    find.unsaved_endpoints.append(Endpoint(protocol=parts.scheme,
                                                           host=parts.netloc,
                                                           path=parts.path,
                                                           query=parts.query,
                                                           fragment=parts.fragment))
                items.append(find)
        return items


def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it
    @return An attribute value
    """
    global ETREE_VERSION
    node = None

    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:

        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'", subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


class Site(object):
    def __init__(self, item_node):
        self.node = item_node
        self.host = self.node.get('host')
        self.ip = self.resolve(self.host)
        self.port = self.node.get('port')
        self.items = []
        for alert in self.node.findall('alerts/alertitem'):
            self.items.append(Item(alert))

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.
        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host


class Item(object):
    """
    An abstract representation of a Item
    @param item_node A item_node taken from an zap xml tree
    """

    def __init__(self, item_node):
        self.node = item_node

        self.id = self.get_text_from_subnode('pluginid')
        self.name = self.get_text_from_subnode('alert')

        self.severity = self.get_text_from_subnode('riskcode')
        self.riskdesc = self.get_text_from_subnode('riskdesc')
        self.desc = self.get_text_from_subnode('desc')
        self.resolution = self.get_text_from_subnode('solution') if self.get_text_from_subnode('solution') else ""
        self.desc += "\n\nReference: " + self.get_text_from_subnode('reference') if self.get_text_from_subnode(
            'reference') else ""
        self.ref = []
        if self.get_text_from_subnode('cweid'):
            self.ref.append("CWE-" + self.get_text_from_subnode('cweid'))
            self.cwe = self.get_text_from_subnode('cweid')
        else: self.cwe = 0

        description_detail = "\n"
        for instance in item_node.findall('instances/instance'):
            for node in instance.getiterator():
                if node.tag == "uri":
                    if node.text != "":
                        description_detail += "URL: " + node.text
                if node.tag == "method":
                    if node.text != "":
                        description_detail += "Method: " + node.text
                if node.tag == "param":
                    if node.text != "":
                        description_detail += "Parameter: " + node.text
                if node.tag == "evidence":
                    if node.text != "":
                        description_detail += "Evidence: " + node.text
                description_detail += "\n"

        self.desc += description_detail

        if self.get_text_from_subnode('wascid'):
            self.ref.append("WASC-" + self.get_text_from_subnode('wascid'))

        self.items = []
        i = 0

        for n in item_node.findall('instances/instance/uri'):
            n2 = None
            if item_node.findall('instances/instance/param'):
                n2 = item_node.findall('instances/instance/param')[i]

            mregex = re.search(
                "^\s*((?P<protocol>.*?)\:\/\/)?((?P<username>.*?)(\:(?P<password>.*))?\@)?((?P<hostname>.*?)(\:((?P<port>[0-9]+)))?)(?P<path>/.*?)?(?P<query>\?.*?)?(?P<fragment>\#.*?)?\s*$",
                n.text)
            if os.environ.get("debug", False):
                print("Parsed URL: protocol='{}', username='{}', password='{}', hostname='{}', port='{}', path='{}', query='{}', fragment='{}'".format(
                    mregex.group('protocol'),
                    mregex.group('username'),
                    mregex.group('password'),
                    mregex.group('hostname'),
                    mregex.group('port'),
                    mregex.group('path'),
                    mregex.group('query'),
                    mregex.group('fragment')
                ))

            protocol = mregex.group('protocol')
            host = mregex.group('hostname')
            port = 80
            if protocol == 'https':
                port = 443
            if mregex.group('port') is not None:
                port = mregex.group('port')

            item = {'uri': n.text, 'param': n2.text if n2 else "", 'host': host, 'protocol': protocol, 'port': port}
            self.items.append(item)
            i = i + 1
        self.requests = "\n".join([i['uri'] for i in self.items])

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.
        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None